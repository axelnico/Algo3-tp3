\section{Ejercicio 1: Solución exacta}

  \begin{figure}[ht]
    \begin{center}
      \includegraphics[width=0.5\columnwidth]{imagenes/pacman.png}
      \caption{Perdidos y con poca fuerza}
    \end{center}
  \end{figure}

    % 1. Describir detalladamente el problema a resolver dando ejemplos del mismo y sus soluciones.
    \subsection{Descripción del problema y solución propuesta}
        En este primer acercamiento, se pidió realizar un algoritmo exacto que resuelva el problema en cuetión. El mísmo debía contener podas y estrategias que permitan mejorar el tiempo de ejecución pero que aseguren devolver la solución correcta (en caso de haber).

        Una solución existe cuando se pueden conquistar todos los gimnasios y además es exacta cuando se conquistan todos ellos recorriendo la menor distancia posible.

    % 2. Explicar de forma clara, sencilla, estructurada y concisa, las ideas desarrolladas para la resolución del problema. Utilizar pseudocódigo y lenguaje coloquial (no código fuente). Justificar por qué el procedimiento resuelve efectivamente el problema.
        Dado que nuestro problema es una instancia del TSP mencionado en la introducción, resolvimos encontrar la solución exacta utilizando la técnica de \textit{backtracking}. Esto es probar todas las soluciones posibles descartando la mayor cantidad que no sean correctas a la vez mediante el uso de \textit{podas}, para así obtener lo más rápido posible la solución correcta; Cada solución se obtiene de manera constructiva de manera tal que en cada iteración se agrega parte de una posible solución. En este caso, lo que se hace es recorrer el grafo desde cada nodo probando todos los caminos posibles, es decir, partiendo de cada gimnasio o pokeparada, ir a todos los demas de todas las formas posibles sin pasar dos veces por el mismo lugar. Las podas utilizadas fueron las siguientes:
            \begin{itemize}
                \item{Verificar al principio que dado posiones($g$) el número de posiones para un gimnasio $g$, \newline $\sum_{g \in Gimnasios} posiones(g) \leq m*3$ con $m$ cantidad de pokeparadas}
                \item{Verificar al principio que $k \geq$ max(posiones($g$)) para algún $g \in Gimnasios$ y $k$ el tamaño de la mochila}
                \item{Chequear que en todo momento el recorrido que se está llevando a cabo tiene longitud menor o igual a la solución actual si es que ya se encontró una}
                \item{No pasar por pokeparadas si la mochila está llena}

        En cada iteración, se visita un nuevo punto (gimnasio o pokeparada), agregando la distancia correspondiente a la posible solución.


        \subsection{Detalles implementativos}
            Para modelar las pokeparadas y gimnasios, implementamos la clase \textit{Estacion}, la cual consiste en un booleano para decidir si es gimasio o pokeparada, un entero que indica la cantidad de posiones y un id único para cada estación (el cual se da segun el número de linea de la entrada). Para determinar el valor de posiones, en el caso de las pokeparadas es simplemente 3 ya que es la cantidad que entrega cada pokeparada, mientras que en el caso de los gimnasios es 0 menos el número que se pasa en el input. Esto es porque en el momento de decidir si hay que agregar o quitar posiones a la cantidad de posiones que se tienen en la mochila es realizar siempre la suma $posionesActuales + posionesEstacion$ evitando la consulta de si la estación es una pokeparada o un gimnasio.

            Para trabajar las distancias entre cada punto, construímos una matriz formada con vectores de vectores, en los que cada índice es el ID del primer nodo con el ID del segundo y para cada posicion $(i,v)$ se encuentra la distancia entre esos dos nodos, la cual se calcula mediante pitágoras.

            La función principal de Backtracking recibe como parámetros un vector de Estaciones, que consiste en todas las estaciones aún no visitadas ($estaciones$), la matriz de distancias ($distancias$), el tamaño de la mochila ($k$), un vector de Estaciones visitadas ($visitados$), la cantidad de posiones actuales ($potasActuales$) y una tuplas de $double$, $int$ y vector de $int$ que representa la solución actual ($solucion$). La misma realiza la lógica descripta en el siguiente pseudocódigo:

            \begin{codesnippet}
            \begin{verbatim}
BT_capturar_gimnasios(vector<Estacion> estaciones, vector< vector<double> > distancias,
entero k, vector<Estacion> visitados, entero potasActuales,
tupla<double,int,vector<int> > soluciones):
  si es solucion(estaciones):
    distancia = distancia_acumulada(visitados,distancias)
    vector<int> camino
    para i = 0 hasta tamaño(visitados):
      agregar id(visitados[i]) a camino
    fin para
    soluciones = tupla(distancia, tamaño(visitados), camino)
  si no:
    para i = 0 hasta tamaño(estaciones):
      nueva_distancia = 0;
      si tamaño(visitados) > 0:
        id_ultimo_visitado = id(ultimo(visitados))
        proxima_distancia = distancias[id_ultimo_visitado][id(estaciones[i])]
        nueva_distancia = proxima_distancia + distancia_acumulada(visitados,distancias)
      fin si
      si (soluciones[0] >= 0 y nueva_distancia < soluciones[0] ó soluciones[0] < 0):
        si (puede_ganar_gimnasio(estaciones[i],potasActuales) ó
            puede_recibir_potas(estaciones[i],potasActuales,k)):
          agregar estaciones[i] a visitados
          si (esGimnasio(estaciones[i]) ó potasActuales + 3 <= k)
            potasActuales = potasActuales + estaciones[i].potas
          si no
            k
          fin si
          borrar elemento con índice i de estaciones
          BT_capturar_gimnasios(estaciones,distancias,k,visitados,potasActuales,soluciones)
          ultimaEstacion = ultimo(visitados)
          eliminar el último de visitados
          insertar ultimaEstacion en posición i de estaciones
        fin si
      fin si
    fin para
  fin si
  devolver soluciones
fin BT_capturar_gimnasios
            \end{verbatim}
            \end{codesnippet}

            En cada iteración de la función, se chequea si el estado actual de los parametros es una solución al problema. Para esto, se revisa todo el vector de estaciones en búsqueda de algúna Estación que sea gimnasio. Si no hay, entonces efectivamente es una solución y se construye la tupla con lo que devuelve el algoritmo para luego imprimir el output correspondiente. Caso contrario, se recorre todo el vector de estaciones para chequear todos los posibles lugares a los que se puede ir desde la ubicación actual e ir a todos ellos.

            Para decidir si podemos ir o no a una estación chequeamos la cantidad de posiones actuales junto con el tamaño de la mochila y las posiones de la estación a la que se desea ir. Si es un gimnasio, analizamos si $posionesActuales + posiones(gimnasio) > 0$. Dado que el gimnasio tiene la cantidad de posiones en negativo (como mencionamos anteriormente), si esta suma deciende de 0 entonces quiere decir que las posiones que tenemos en la mochila no son suficientes para conquistar ese gimnasio, por lo que no tendría sentido ir ya que esto solamente aumentaría la distancia recorrida (y esto último ocurre porque como todas las estaciones están conectadas,  $\forall v,w,r : distancia(v,w) \leq distancia(v,r) + distancia(r,w)$). Si es una pokeparada, observamos si $posionesActuales < k$ con $k$ tamaño de la mochila. La razón es que cada pokeparada otorga 3 posiones pero si la mochila está llena entonces se descartan las excedentes; y teniendo en cuenta lo dicho recientemente, si hay solución debería existir otra estación tal que se pueda visitar sin agregar innecesariamente distancia recorrida a la solución actual.

            Antes de entrar en la función descripta, se realizan dos chequeos. Primero, que no exista un gimnasio cuya cantidad de posiones sea mayor al tamaño de la mochila, ya que si esto ocurriera, incluso pasando por todas las pokeparadas posibles nunca alcanzaríamos la cantidad necesaria para conquistar ese gimnasio. En segundo lugar, que la suma total de posiones necesarias para conquistar a cada gimnasio sea menor o igual a la cantidad de $pokeparadas*3$.


    % 3. Deducir una cota de complejidad temporal del algoritmo propuesto y justificar por qué el algoritmo cumple la cota dada. Utilizar el modelo uniforme.
    \subsection{Complejidad teórica}

      Para este análisis, nuevamente separaremos el algoritmo en dos partes (construcción del grafo y BFS). En la primera parte, se generan $P+1$ niveles de $FC$ nodos que como se explica en el punto anterior, se representan mediante listas de adyacencias. Agregar una arista entre dos nodos cuesta $O(1)$ ya que es simplemente agregar el número de nodo destino de la arista a la lista de adyacencia del nodo origen. Hacer esto por cada nodo costaría $O(|E|)$ por cada nivel con $|E|$ siendo el número de aristas. Sin embargo, al ser un digrafo tipo \textit{grid}, la cantidad máxima de aristas por nodo es de 4 porque cada nodo se conecta con, a lo sumo, un nodo a cada lado (izquierda, derecha, arriba y abajo). Además, si bien hay $FC$ nodos en cada nivel, los nodos que sean paredes no tendrán aristas de entrada que provengan de nodos del mismo piso. Luego, $|E| \leq 4FC \in O(FC)$. Como esto ocurre $P+1$ veces, la complejidad de la primera parte es

      \[
        O((P+1)FC) \in O(FCP)
      \]


      La segunda parte, el algoritmo conocido como \textit{BFS}, tiene complejidad $O(|V| + |E|)$ siendo $|V|$ la cantidad de nodos. Ya probamos que $|E| \in O(FCP)$ y sabemos que $|V| = FC$, entonces la complejidad de la segunda parte es

      \[
        O(FC + FCP) \in O(FCP)
      \]

      Considerando las dos partes juntas, nos queda que la complejidad temporal es

      \[
        O(FCP + FCP) \in O(FCP)
      \]

      En cuanto a la complejidad espacial, el tamaño del grafo sobre listas de adyacencias es de $O(FCP)$ ya que es la cantidad de nodos totales sumado a lo que, por lo probado anteriormente, acota la cantidad de aristas totales.


    % 4. Dar un código fuente claro que implemente la solución propuesta. Se deben incluir las partes relevantes del código como apéndice del informe impreso entregado.

    % 5. Realizar una experimentación computacional para medir la performance del programa implementado. Usar un conjunto de casos de test en función de los parámetros de entrada, con instancias aleatorias e instancias particulares (de peor/mejor caso en tiempo de ejecución, por ejemplo). Presentar en forma gráfica una comparación entre los tiempos medidos y la complejidad teórica calculada y extraer conclusiones.
    \subsection{Experimentación}

	Para poder mostrar que la cota propuesta en la complejidad temporal funciona para el algoritmo que resuelve este problema, realizamos experimentos con diferentes matrices y diferentes cantidades de paredes que se pueden destruir.

  Primero se realizó un experimento con 5 matrices de tamaño 10x10. Una matriz estaba compuesta por todas paredes excepto el origen y el destino, otra tenia la mitad de paredes horizontales respecto del total de nodos, otra la mitad de paredes verticales, otra la mitad de paredes diagonales y la última no contenía ninguna pared y el origen y el destino estaban uno al lado del otro. Se optó por realizarlo de esta forma ya que se pueden probar casos límite, que son cuando se tienen que romper todas paredes, mientras que en el lado opuesto no hay que romper ninguna y el destino está a un sólo nodo de distancia del origen. Por como esta implementado el algoritmo se esperó que en los casos en donde hay que romper mucha más cantidad de paredes tarden más en ejecutarse que los que no hay que romper ninguna y además está más cerca el nodo destino del origen. Los esquemas de las matrices que se utilizaron para realizar esta parte del experimento son los siguientes:

 \begin{codesnippet}
            \begin{verbatim}
o # # # # # # # # #
# # # # # # # # # #
# # # # # # # # # #
# # # # # # # # # #
# # # # # # # # # #
# # # # # # # # # #
# # # # # # # # # #
# # # # # # # # # #
# # # # # # # # # #
# # # # # # # # # x

o # . # . # . # . #
. # . # . # . # . #
. # . # . # . # . #
. # . # . # . # . #
. # . # . # . # . #
. # . # . # . # . #
. # . # . # . # . #
. # . # . # . # . #
. # . # . # . # . #
. # . # . # . # . x

o # # # # # # # # #
. . . . . . . . . .
# # # # # # # # # #
. . . . . . . . . .
# # # # # # # # # #
. . . . . . . . . .
# # # # # # # # # #
. . . . . . . . . .
# # # # # # # # # #
. . . . . . . . . x

o # . # . # . # . #
# . # . # . # . # .
. # . # . # . # . #
# . # . # . # . # .
. # . # . # . # . #
# . # . # . # . # .
. # . # . # . # . #
# . # . # . # . # .
. # . # . # . # . #
# . # . # . # . # x

o x . . . . . . . .
. . . . . . . . . .
. . . . . . . . . .
. . . . . . . . . .
. . . . . . . . . .
. . . . . . . . . .
. . . . . . . . . .
. . . . . . . . . .
. . . . . . . . . .
. . . . . . . . . .

\end{verbatim}
            \end{codesnippet}

  El expermiento se corrío para cada matriz teniendo en cuenta que se pueden romper desde 0 hasta 99 paredes. Es decir, en total se examinaron 500 casos (100 para cada una de las cinco matrices). Además para cada caso con una determinada cantidad de paredes, se repitió el mismo experimento 100 veces para luego tomar el promedio y obtener un resultado más representativo del tiempo que tarda cada caso. Los primeros casos en los que se podían romper pocas paredes fueron los que menos tiempo de ejecución demandaron.
  Los resultados obtenidos fueron plasmados en el siguiente gráfico. El mismo es la representación del tiempo en funcion de la cantidad de paredes que se pueden romper para cada una de las cinco matrices consideredas. También se muestra la funcion propuesta como cota de complejidad temporal.

  \begin{figure}[H]
      \begin{center}
        \includegraphics[width=0.7\columnwidth]{../exp/ej1tamanosFijos.jpeg}
        \caption{}
      \end{center}
  \end{figure}

  Para cada matriz puede observarse que a medida que crece la cantidad de paredes que se pueden derribar, también crece el tiempo que toma cada ejecución del programa, que era el comportamiento que se esperaba. Si bien el algoritmo de BFS corta la ejecución en cuanto encuentra el destino (en caso de poder encontrarse), no se observa una mejoría cuando se utiliza una cantidad mayor de paredes que se pueden destruir a la cantidad de nodos, debido a que en la construcción del grafo se toman en cuenta todos los niveles (cantidad de paredes), por lo que esa parte del algoritmo ya toma $O(FCP)$. Por esta razón es que el tiempo de ejecución no se mantiene constante una vez que se toma una cantidad de paredes mayor al total de nodos. El algortimo como se puede observar también tarda menos en ejecutar cuando en la matriz no hay ninguna pared y el origen y el destino están uno al lado del otro, como se esperaba. Este es el mejor caso. Los casos en los cuales había una cantidad de paredes igual a la mitad de nodos y éstas estaban en posiciones horizontales y verticales fueron aún peor que en el caso que son todas paredes. Esto puede explicarse debido a que el algoritmo de BFS inspecciona algunos vecinos que en el caso de que son todas paredes no puede ya que no tiene ningún camino que pueda pasar sin romper paredes.
  Podemos notar como la cota de complejidad cumple, aunque no de manera exacta, su función para estos experimentos.


  Luego se realizó otro tipo de experimento en el cual se utilizaron otras cinco matrices pero con tamaño y paredes dispuestas de manera aleatoria. Estas matrices fueron generadas usando la librería random de la STL con distribución uniforme. Este experimento se corrió bajo las mismas circunstancias que el otro experimento. Se corrieron 100 casos para cada una de las matrices, considerando que se pueden romper desde 0 a 99 paredes. Además también cada uno de los casos se repitió 100 veces y se tomó el promedio. Los resultados que se obtuvieron son los siguientes:

  \begin{figure}[H]
      \begin{center}
        \includegraphics[width=0.7\columnwidth]{../exp/ej1tamanosRandom.jpeg}
        \caption{}
      \end{center}
  \end{figure}

  Se observa también como el tiempo de ejecución aumenta a medida de que se pueden romper más paredes para cada una de las matrices. Por lo general, los casos en los cuales la matriz tiene menos filas y columnas presentan un tiempo de ejecución menor pero pueden observarse que igualmente también depende de la cantidad de paredes que haya en la matriz. Para estos casos, la cota propuesta acota mejor de manera superior a todos los casos.

