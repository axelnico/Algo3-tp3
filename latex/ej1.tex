\section{Ejercicio 1: Solución exacta}

  % \begin{figure}[ht]
  %   \begin{center}
  %     \includegraphics[width=0.5\columnwidth]{imagenes/pacman.png}
  %     \caption{Perdidos y con poca fuerza}
  %   \end{center}
  % \end{figure}

    % 1. Describir detalladamente el problema a resolver dando ejemplos del mismo y sus soluciones.
    \subsection{Descripción del problema y solución propuesta}
        En este primer acercamiento, se pidió realizar un algoritmo exacto que resuelva el problema en cuestión. El mísmo debía contener podas y estrategias que permitan mejorar el tiempo de ejecución pero que aseguren devolver la solución correcta (en caso de haber).

        Una solución existe cuando se pueden conquistar todos los gimnasios y además es exacta cuando se conquistan todos ellos recorriendo la menor distancia posible.

    % 2. Explicar de forma clara, sencilla, estructurada y concisa, las ideas desarrolladas para la resolución del problema. Utilizar pseudocódigo y lenguaje coloquial (no código fuente). Justificar por qué el procedimiento resuelve efectivamente el problema.
        Dado que nuestro problema es una instancia del TSP mencionado en la introducción, resolvimos encontrar la solución exacta utilizando la técnica de \textit{backtracking}. Esto es probar todas las soluciones posibles descartando la mayor cantidad que no sean correctas a la vez mediante el uso de \textit{podas}, para así obtener lo más rápido posible la solución correcta. Cada solución se  construye de manera tal que en cada iteración se agrega parte de una posible solución. En este caso, lo que se hace es recorrer el grafo desde cada nodo probando todos los caminos posibles, es decir, partiendo de cada gimnasio o pokeparada, conquistar todos los gimnasios pociones todas las formas posibles sin pasar dos veces por el mismo lugar. Las podas utilizadas fueron las siguientes:
            \begin{itemize}
                \item{Verificar al principio que dado pociones($g$) el número de pociones para un gimnasio $g$, \newline $\sum_{g \in Gimnasios} pociones(g) \leq m*3$ con $m$ cantidad de pokeparadas no recorridas}
                \item{Verificar al principio que $\forall g \in Gimnasios$ ($k \geq$ pociones($g$)) con $k$ el tamaño de la mochila}
                \item{Chequear que en todo momento el recorrido que se está llevando a cabo tiene distancia menor o igual a la solución actual si es que ya se encontró una}
                \item{No pasar por pokeparadas si la mochila está llena}
            \end{itemize}

        En cada iteración, se visita un nuevo punto (gimnasio o pokeparada), agregando la distancia correspondiente a la posible solución.


        \subsection{Detalles implementativos}
            Para modelar las pokeparadas y gimnasios, implementamos la clase \textit{Estacion}, la cual consiste en: un booleano para decidir si es gimasio o pokeparada, un entero que indica la cantidad de pociones y un id único para cada estación (el cual se da segun el número de linea de la entrada). Para determinar el valor de pociones, en el caso de las pokeparadas es simplemente 3 ya que es la cantidad que entrega cada una, mientras que en el caso de los gimnasios es 0 menos el número de pociones necesarias para ganarlo, que se pasa en el input. Esto es justamente porque los gimnasios consumen pociones de la mochila.

            Para trabajar las distancias entre cada punto, construímos una matriz formada con vectores de vectores, en los que cada índice es el ID del primer nodo con el ID del segundo y para cada posicion $(i,v)$ se encuentra la distancia entre los nodos i y j, la cual se calcula mediante pitágoras.

            La función principal de Backtracking recibe como parámetros un vector de Estaciones, que consiste en todas las estaciones aún no visitadas ($estaciones$), la matriz de distancias ($distancias$), el tamaño de la mochila ($k$), un vector de Estaciones visitadas ($visitados$), la cantidad de pociones actuales ($potasActuales$) y una tupla de $double$, $int$ y vector de $int$ que representa la solución actual ($solucion$). La misma realiza la lógica descripta en el siguiente pseudocódigo:

            \begin{codesnippet}
            \begin{verbatim}
BT_capturar_gimnasios(lista<Estacion> estaciones, lista< lista<double> > distancias,
entero k, lista<Estacion> visitados, entero potasActuales,
tupla<double,entero,lista<IDs> > soluciones):
  si es solucion(estaciones):
    distancia = distancia_acumulada(visitados,distancias)
    lista<IDs> camino                                   //(un ID es un numero entero)
    para i = 0 hasta tamaño(visitados):
      agregar id(visitados[i]) a camino
    fin para
    soluciones = tupla(distancia, tamaño(visitados), camino)
  si no:
    para i = 0 hasta tamaño(estaciones):
      nueva_distancia = 0;
      si tamaño(visitados) > 0:
        id_ultimo_visitado = id(ultimo(visitados))
        proxima_distancia = distancias[id_ultimo_visitado][id(estaciones[i])]
        nueva_distancia = proxima_distancia + distancia_acumulada(visitados,distancias)
      fin si
      si (soluciones[0] >= 0 y nueva_distancia < soluciones[0] ó soluciones[0] < 0):
        si (puede_ganar_gimnasio(estaciones[i],potasActuales) ó
            puede_recibir_potas(estaciones[i],potasActuales,k)):
          agregar estaciones[i] a visitados
          si (esGimnasio(estaciones[i]) ó potasActuales + 3 <= k)
            potasActuales = potasActuales + estaciones[i].potas
          si no
            potasActuales = k
          fin si
          borrar elemento con índice i de estaciones
          BT_capturar_gimnasios(estaciones,distancias,k,visitados,potasActuales,soluciones)
          ultimaEstacion = ultimo(visitados)
          eliminar el último de visitados
          insertar ultimaEstacion en posición i de estaciones
        fin si
      fin si
    fin para
  fin si
  devolver soluciones
fin BT_capturar_gimnasios
            \end{verbatim}
            \end{codesnippet}

            En cada iteración de la función, se chequea si el estado actual de los parametros es una solución al problema. Para esto, se revisa todo el vector de estaciones en búsqueda de algúna Estación que sea gimnasio. Si no hay, entonces efectivamente es una solución y se construye la tupla con lo que devuelve el algoritmo para luego imprimir el output correspondiente. Caso contrario, se recorre todo el vector de estaciones para chequear todos los posibles lugares a los que se puede ir desde la ubicación actual e ir a todos ellos.

            Para decidir si podemos ir o no a una estación chequeamos la cantidad de pociones actuales junto con el tamaño de la mochila y las pociones de la estación a la que se desea ir. Si es un gimnasio, analizamos si $pociones + pociones(gimnasio) > 0$. Dado que el gimnasio tiene la cantidad de pociones en negativo (como mencionamos anteriormente), si esta suma deciende de 0 entonces quiere decir que las pociones que tenemos en la mochila no son suficientes para conquistar ese gimnasio, por lo que no tendría sentido ir ya que esto solamente aumentaría la distancia recorrida (y esto último ocurre porque como todas las estaciones están conectadas,  $\forall v,w,r : distancia(v,w) \leq distancia(v,r) + distancia(r,w)$). Si es una pokeparada, observamos si $pociones = k$ con $k$ tamaño de la mochila. La razón es que cada pokeparada otorga 3 pociones pero si la mochila se llena entonces se descartan las excedentes, mas si la mochila esta totalmente llena, se descartan todas las pociones de esa pokeparada; y teniendo en cuenta lo dicho recientemente, si hay solución debería existir otra estación tal que se pueda visitar sin agregar innecesariamente distancia recorrida a la solución actual.

            Antes de entrar en la función descripta, se realizan dos chequeos (las podas). Primero, que no exista un gimnasio cuya cantidad de pociones sea mayor al tamaño de la mochila, ya que si esto ocurriera, incluso pasando por todas las pokeparadas posibles nunca alcanzaríamos la cantidad necesaria para conquistar ese gimnasio. Un ejemplo puede ser 2 pokeparadas, 1 gimnasio que necesita 10 pociones y tamaño de mochila 9. En segundo lugar, que la suma total de pociones necesarias para conquistar a cada gimnasio sea menor o igual a la cantidad de $pokeparadas*3$. Esto se hace para descartar los casos en los que incluso teniendo el tamaño de mochila suficiente para guardar todas las pociones de todas las pokeparadas, las mismas no alcancen para conquistar todos los gimnasios. Un caso ejemplo sería 1 pokeparada, 2 gimnasios que necesitan 3 pociones y tamaño de mochila 3.


    % 3. Deducir una cota de complejidad temporal del algoritmo propuesto y justificar por qué el algoritmo cumple la cota dada. Utilizar el modelo uniforme.
    \subsection{Complejidad teórica}

      La primeras dos podas, que son los chequeos que se realizan antes de llamar a la función principal, consisten en recorrer el vector de Estaciones sumando y restando valores de pociones, por lo que es $O(n+m)$ temporal y $O(1)$ espacial ya que solo crean 2 variables enteras.

      El algoritmo principal lo primero que hace es chequear si el estado actual de los parámentros, como se dijo anteriormente, corresponden a una solución del problema. Este análisis toma $O(n+m)$ temporal y $O(1)$ espacial ya que solo es recorrer el vector de Estaciones para chequear si existen gimnasios no visitados. Si es solución, se obtiene la distancia acumulada, que toma $O(n+m)$ ya que es solamente recorrer el vector de visitados (y por lo tanto $O(1)$ espacial) y luego se recorre nuevamente el mismo vector para obtener el camino que se realizó, costando $O(n+m)$ temporal y $O(1)$ espacial.
      Si no es solución se recorren todas las estaciones del vector estaciones (que tomará $O(n+m)$) realizando los siguientes pasos para cada una: Si la cantidad de Estaciones visitadas es mayor a 0 (cosa que no ocurrirá solamente en la primera iteración) se obtiene la distancia acumulada más la proxima distancia a sumar, que como dijimos en el párrafo anterior cuesta $O(n+m)$. Luego, si esa distancia es menor que la distancia de la solución encontrada hasta ahora (si la hubiera) y puede ir a conquistar el gimnasio (si el la próxima posición lo es) o la cantidad de pociones es menor al tamaño de la mochila (y la próxima posición es una pokeparada), se agrega al vector de visitados la próxima estación ($O(1)$ amortizado), se actualiza el valor de pociones ($O(1)$), se elimina la estación del vector estaciones ($O(n+m)$), se llama a la función recursiva (luego explicado) y por último se vuelve al estado original los vectores de visitados y estaciones ($O(n+m)$ temporal y $O(1)$ espacial cada uno).
      El llamado a la función recursiva hace que para cada Estación del vector de estaciones se recorran todas las demás en búsqueda de una solución, por lo que una iteración tomaría $O(n+m)$ temporal y como todos los vectores se pasan siempre por referencia, solo tomaría $O(1)$ espacial (sin contar el overhead en el $stack$ de llamadas recursivas). Luego, como en cada iteración se realiza todo lo mencionado, en total costará
      \[
        O(\prod_{i=0}^{n+m} i)*O(n+m)
      \]
      \[
        \in O((n+m)! * (n+m))
      \]

      Por lo que el algoritmo tiene complejidad temporal $O((n+m)! * (n+m))$ y espacial $O((n+m)^2)$ por la matriz de distancia que se construye antes de llamar a la función principal.

    % 4. Dar un código fuente claro que implemente la solución propuesta. Se deben incluir las partes relevantes del código como apéndice del informe impreso entregado.

    % 5. Realizar una experimentación computacional para medir la performance del programa implementado. Usar un conjunto de casos de test en función de los parámetros de entrada, con instancias aleatorias e instancias particulares (de peor/mejor caso en tiempo de ejecución, por ejemplo). Presentar en forma gráfica una comparación entre los tiempos medidos y la complejidad teórica calculada y extraer conclusiones.
    \subsection{Experimentación}

      Los experimentos que realizamos para observar los tiempos de ejecución del algoritmo en función del tamaño de entrada y de las podas implementadas consistieron en el análisis de casos que contemplan:

      \begin{itemize}
        \item El comportamiento de las podas
        \item Configuraciones de valores que no están en la cota de complejidad
        \item Configuraciones de valores que sí están en la cota de complejidad, dejando fijos los demás
        \item Casos random generados a partir de la librería Random de la STL de C++ utilizando distribución uniforme
      \end{itemize}

      Para todos los casos, el algoritmo se ejecutó 30 veces con cada instancia para intentar tener la mayor presición posible en cuanto a tiempo de ejecución.

      \subsubsection{Analisis de las podas}
      En esta instancia generamos entradas que aumentaban linealmente de 1 a 10 la cantidad de pokeparadas y gimnasios, variando el tamaño de la mochila y marcando a cada gimnasio con la cantidad de posiones necesarias igual al numero de linea en el input (para el gimnasio 3, se piden 3 posiones). Además, las ubicaciones de cada estación se setearon cada una a distancia 1 de la anterior y la siguiente: para la estación $i$ la ubicación es ($i$,$i$).

      Algunos ejemplos para el input de este experimento son los siguientes:


 \begin{codesnippet}
            \begin{verbatim}
8 8 36        9 9 45        10 10 55
1 1 1         1 1 1         1 1 1
2 2 2         2 2 2         2 2 2
3 3 3         3 3 3         3 3 3
4 4 4         4 4 4         4 4 4
5 5 5         5 5 5         5 5 5
6 6 6         6 6 6         6 6 6
7 7 7         7 7 7         7 7 7
8 8 8         8 8 8         8 8 8
9 9           9 9 9         9 9 9
10 10         10 10         10 10 10
11 11         11 11         11 11
12 12         12 12         12 12
13 13         13 13         13 13
14 14         14 14         14 14
15 15         15 15         15 15
16 16         16 16         16 16
              17 17         17 17
              18 18         18 18
                            19 19
                            20 20

\end{verbatim}
            \end{codesnippet}

  
  \begin{figure}[H]
      \begin{center}
        \includegraphics[width=0.7\columnwidth]{imagenes/exp1_ej1.jpeg}
        \caption{}
      \end{center}
  \end{figure}

  % Para cada matriz puede observarse que a medida que crece la cantidad de paredes que se pueden derribar, también crece el tiempo que toma cada ejecución del programa, que era el comportamiento que se esperaba. Si bien el algoritmo de BFS corta la ejecución en cuanto encuentra el destino (en caso de poder encontrarse), no se observa una mejoría cuando se utiliza una cantidad mayor de paredes que se pueden destruir a la cantidad de nodos, debido a que en la construcción del grafo se toman en cuenta todos los niveles (cantidad de paredes), por lo que esa parte del algoritmo ya toma $O(FCP)$. Por esta razón es que el tiempo de ejecución no se mantiene constante una vez que se toma una cantidad de paredes mayor al total de nodos. El algortimo como se puede observar también tarda menos en ejecutar cuando en la matriz no hay ninguna pared y el origen y el destino están uno al lado del otro, como se esperaba. Este es el mejor caso. Los casos en los cuales había una cantidad de paredes igual a la mitad de nodos y éstas estaban en posiciones horizontales y verticales fueron aún peor que en el caso que son todas paredes. Esto puede explicarse debido a que el algoritmo de BFS inspecciona algunos vecinos que en el caso de que son todas paredes no puede ya que no tiene ningún camino que pueda pasar sin romper paredes.
  % Podemos notar como la cota de complejidad cumple, aunque no de manera exacta, su función para estos experimentos.


  % Luego se realizó otro tipo de experimento en el cual se utilizaron otras cinco matrices pero con tamaño y paredes dispuestas de manera aleatoria. Estas matrices fueron generadas usando la librería random de la STL con distribución uniforme. Este experimento se corrió bajo las mismas circunstancias que el otro experimento. Se corrieron 100 casos para cada una de las matrices, considerando que se pueden romper desde 0 a 99 paredes. Además también cada uno de los casos se repitió 100 veces y se tomó el promedio. Los resultados que se obtuvieron son los siguientes:

  \begin{figure}[H]
      \begin{center}
        \includegraphics[width=0.7\columnwidth]{imagenes/exp2_ej1.jpeg}
        \caption{}
      \end{center}
  \end{figure}

  % Se observa también como el tiempo de ejecución aumenta a medida de que se pueden romper más paredes para cada una de las matrices. Por lo general, los casos en los cuales la matriz tiene menos filas y columnas presentan un tiempo de ejecución menor pero pueden observarse que igualmente también depende de la cantidad de paredes que haya en la matriz. Para estos casos, la cota propuesta acota mejor de manera superior a todos los casos.

  \begin{figure}[H]
      \begin{center}
        \includegraphics[width=0.7\columnwidth]{imagenes/exp3_ej1.jpeg}
        \caption{}
      \end{center}
  \end{figure}
