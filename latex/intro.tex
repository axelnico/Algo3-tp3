\section{Introducción}

Este trabajo es el resultado del estudio de una instancia del \textit{Traveling Salesman Problem}. El TSP (por sus siglas) es conocido en español como "Provlema del viajante", el cual sitúa a un viajero en búsqueda del camino más corto que cumpla ciertas condiciones las cuales, en general, son que debe recorrer distintas ciudades interconectadas sin pasar más de una vez por cada una. En nuestro caso de estudio, tenemos un jugador de \textit{Pokémon GO} en una ciudad en la que hay distintos puntos con 2 posibles características: los \textbf{gimnasios} y las \textbf{pokeparadas}. Los primeros son lugares que el jugador desea conquistar siendo que están, en un comienzo, bajo control del enemigo y para ello debe vencer a los pokemones enemigos utilizando los propios. Un pokemon es una criatura virtual que tiene un poder de ataque y de vida. Para vencer a los enemigos es necesaria una cierta cantidad de posiones, las cuales se obtienen de las pokeparadas. Cada una de ellas le otorga 3 posiones al jugador y la forma en que éste las guarda es en una mochila que tiene una capacidad máxima; si la mochila está llena y el jugador pasa por una pokeparada, las posiones son descartadas. Relacionando ambas ideas, estudiamos nuestra problemática considerando que las restricciones para hallar el camíno mínimo es que dados $n$ la cantidad de gimnasios, $m$ la cantidad de pokeparadas y $k$ el tamaño de la mochila, queremos pasar por todos los gimnasios siempre que tengamos la cantidad de posiones necesarias para capturarlo, que en ningún momento tengamos más posiones que $k$ y, obviamente, no pasar dos veces por el mismo lugar.

Para obtener la solución a este problema, se plantearon 4 formas distintas utilizando las técnicas algorítmicas vistas en la materia y modelando los mismos mediante grafos, siendo cada nodo una pokeparada o un gimnasio. Estos presentaron cada uno un desafío distinto, teniendo que aplicar métodos diferentes para resolverlos y cumplir con los requisitos exigidos.

Además de la resolución de los mismos, se procedió a demostrar la correctitud de
cada implementación. Esto fue acompañado a su vez de una justificación de la
complejidad temporal.

Cada ejercicio contó con su respectiva experimentación para corroborar que la
complejidad temporal teórica se cumpliera y en los casos donde el algoritmo
podía comportarse mejor, verlo reflejado de alguna manera.

Los experimentos contaron con diversas medidas para asegurar su efectividad de
las cuales las siguientes fueron iguales para los tres problemas:
\begin{itemize}
	\item{Sólo se midió el costo temporal de generar la solución, no
			de lectura y escritura del problema.}
	\item{Para la medición del tiempo se utilizó la biblioteca \texttt{chronos}
			con unidad de tiempo en microsegundos.}
\end{itemize}


En todos los casos, el input del programa se dió de la siguiente manera:
Una línea con tres valores enteros positivos, $n$, $m$ y $k$, separados por espacios; los valores $n$ y $m$ indican la cantidad gimnasios y paradas, respectivamente, mientras que $k$ indica el tamaño de la mochila. A continuación, siguen $n$ líneas, representando los gimnasios. Cada una contiene 3 enteros, $x$, $y$ y $p$, donde $x$ e $y$ indican la posición, y $p$ la cantidad de pociones necesarias para vencer el gimnasio. Las siguentes $m$ lineas indican la posición de las pokeparadas, cada una contiene dos enteros $x$ e $y$.